/**
 * Encryption utilities for HashTree
 *
 * Uses AES-256-GCM with random IV stored alongside ciphertext.
 * Format: [12-byte IV][ciphertext][16-byte auth tag]
 *
 * Single 32-byte key encrypts all chunks in a tree.
 * Key is stored in nhash/npath decryptKey field.
 */

/** 32-byte encryption key (256 bits) */
export type EncryptionKey = Uint8Array;

/** IV size for AES-GCM */
const IV_SIZE = 12;

/** Auth tag size for AES-GCM */
const TAG_SIZE = 16;

/** Minimum encrypted data size: IV + tag */
const MIN_ENCRYPTED_SIZE = IV_SIZE + TAG_SIZE;

/** Generate a random 32-byte encryption key */
export function generateKey(): EncryptionKey {
  const key = new Uint8Array(32);
  crypto.getRandomValues(key);
  return key;
}

/**
 * Import raw key bytes as CryptoKey for AES-GCM
 */
async function importKey(key: EncryptionKey): Promise<CryptoKey> {
  // Copy to ensure we have a clean ArrayBuffer (not SharedArrayBuffer)
  const keyBuffer = new ArrayBuffer(key.length);
  new Uint8Array(keyBuffer).set(key);
  return crypto.subtle.importKey(
    'raw',
    keyBuffer,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

/**
 * Encrypt data using AES-256-GCM
 *
 * @param plaintext - Data to encrypt
 * @param key - 32-byte encryption key
 * @returns Encrypted data: [12-byte IV][ciphertext + 16-byte auth tag]
 */
export async function encrypt(plaintext: Uint8Array, key: EncryptionKey): Promise<Uint8Array> {
  if (key.length !== 32) {
    throw new Error('Encryption key must be 32 bytes');
  }

  const iv = new Uint8Array(IV_SIZE);
  crypto.getRandomValues(iv);

  const cryptoKey = await importKey(key);

  // Copy plaintext to clean ArrayBuffer for WebCrypto
  const plaintextBuffer = new ArrayBuffer(plaintext.length);
  new Uint8Array(plaintextBuffer).set(plaintext);

  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    cryptoKey,
    plaintextBuffer
  );

  // Prepend IV to ciphertext
  const result = new Uint8Array(IV_SIZE + ciphertext.byteLength);
  result.set(iv, 0);
  result.set(new Uint8Array(ciphertext), IV_SIZE);

  return result;
}

/**
 * Decrypt data using AES-256-GCM
 *
 * @param encrypted - Encrypted data: [12-byte IV][ciphertext + auth tag]
 * @param key - 32-byte encryption key
 * @returns Decrypted plaintext
 * @throws Error if decryption fails (wrong key or tampered data)
 */
export async function decrypt(encrypted: Uint8Array, key: EncryptionKey): Promise<Uint8Array> {
  if (key.length !== 32) {
    throw new Error('Encryption key must be 32 bytes');
  }
  if (encrypted.length < MIN_ENCRYPTED_SIZE) {
    throw new Error('Encrypted data too short');
  }

  const iv = encrypted.slice(0, IV_SIZE);
  const ciphertext = encrypted.slice(IV_SIZE);

  const cryptoKey = await importKey(key);

  const plaintext = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv },
    cryptoKey,
    ciphertext
  );

  return new Uint8Array(plaintext);
}

/**
 * Check if data could be encrypted (based on minimum size).
 * Note: This is a heuristic - actual encrypted data might be larger.
 */
export function couldBeEncrypted(data: Uint8Array): boolean {
  return data.length >= MIN_ENCRYPTED_SIZE;
}

/**
 * Calculate encrypted size for given plaintext size
 */
export function encryptedSize(plaintextSize: number): number {
  return IV_SIZE + plaintextSize + TAG_SIZE;
}

/**
 * Calculate plaintext size from encrypted size
 */
export function plaintextSize(encryptedSize: number): number {
  return Math.max(0, encryptedSize - IV_SIZE - TAG_SIZE);
}

/** Convert key to hex string */
export function keyToHex(key: EncryptionKey): string {
  return Array.from(key).map(b => b.toString(16).padStart(2, '0')).join('');
}

/** Convert hex string to key */
export function keyFromHex(hex: string): EncryptionKey {
  if (hex.length !== 64) {
    throw new Error('Key hex must be 64 characters (32 bytes)');
  }
  const key = new Uint8Array(32);
  for (let i = 0; i < 32; i++) {
    key[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return key;
}
